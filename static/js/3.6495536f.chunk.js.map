{"version":3,"sources":["../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm_bg.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","isLikeNone","x","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","__wbg_adapter_34","arg0","arg1","makeMutClosure","dtor","f","state","a","b","cnt","real","args","get","original","__wbg_adapter_37","__wbg_adapter_40","arg2","_assertClass","instance","klass","extract_hints","signed_transaction","state_context","boxes_to_spend","_data_boxes","real_propositions","simulated_propositions","retptr","Transaction","ptr0","ErgoStateContext","ErgoBoxes","Propositions","ptr1","ptr2","r0","r1","TransactionHintsBag","__wrap","cachegetUint32Memory0","getUint32Memory0","Uint32Array","passArrayJsValueToWasm0","array","getArrayU8FromWasm0","passArray8ToWasm0","getArrayJsValueFromWasm0","result","base16_decode","data","len0","r2","v1","stack_pointer","verify_signature","address","signature","Address","len1","passArray32ToWasm0","get_info","node","NodeConf","get_nipopow_proof_by_header_id","min_chain_length","suffix_len","header_id","BlockId","peer_discovery","seeds","max_parallel_requests","timeout_sec","handleError","apply","this","e","NetworkPrefix","Object","freeze","Mainnet","Testnet","AddressTypePrefix","P2Pk","Pay2Sh","Pay2S","NonMandatoryRegisterId","R4","R5","R6","R7","R8","R9","__destroy_into_raw","network_prefix","v0","ErgoTree","create","prototype","ergo_tree","bytes","s","BatchMerkleProof","expected_root","json","addBorrowedObject","BlockHeader","BlockHeaders","index","json_vals","BoxId","box_id_str","BoxSelection","boxes","change","ErgoBoxAssetsDataList","BoxValue","I64","v","CommitmentHint","Constant","r3","ErgoBox","base16_bytes_str","num","arr","bytes1","bytes2","l1","l2","ContextExtension","id","value","key","Contract","recipient","source","DataInput","box_id","DataInputs","elem","DerivationPath","acc","address_indices","path","creation_height","contract","tx_id","tokens","TxId","Tokens","register_id","ErgoBoxAssetsData","ErgoBoxCandidate","fee_amount","ErgoBoxCandidateBuilder","new_min_value_per_byte","new_value","token","token_name","token_desc","num_decimals","Token","token_id","amount","TokenId","TokenAmount","ErgoBoxCandidates","box_candidate","pre_header","headers","PreHeader","constant","ExtPubKey","public_key_bytes","chain_code","derivation_path","ExtSecretKey","secret_key_bytes","seed_bytes","HintsBag","hint","other","string","Input","ProverResult","Inputs","LevelNode","hash","side","MerkleProof","level","leaf_data","MinerAddress","Mnemonic","mnemonic_phrase","mnemonic_pass","v2","NetworkAddress","network","NipopowProof","NipopowVerifier","addr","PeerUrls","PoPowHeader","block_header","proposition","ReducedTransaction","UnsignedTransaction","unsigned_tx","data_boxes","SecretKey","SecretKeys","SimpleBoxSelector","inputs","target_balance","target_tokens","str","proofs","hints_bag","TxBuilder","data_inputs","context_extension","box_selection","output_candidates","current_height","change_address","min_change_value","UnsignedInput","ext","UnsignedInputs","input_id","Wallet","secret","_state_context","tx","tx_hints","reduced_tx","__wbindgen_object_drop_ref","__wbindgen_string_new","__wbindgen_number_new","__wbindgen_json_parse","parse","__wbindgen_json_serialize","__wbindgen_error_new","__wbg_nipopowproof_new","__wbg_peerurls_new","__wbindgen_is_string","__wbindgen_string_get","__wbindgen_object_clone_ref","__wbg_fetch_2f012da7b5bb0447","fetch","__wbindgen_cb_drop","__wbg_instanceof_Window_434ce1849eb4e0fc","Window","__wbg_performance_bbca4ccfaef860b2","performance","__wbg_setTimeout_1c75092906446b91","setTimeout","arguments","__wbg_fetch_fe54824ee845f6b4","__wbg_new_226d109446575877","Headers","__wbg_append_4d85f35672cbffa7","arg3","arg4","append","__wbg_signal_259ba662a5555524","signal","__wbg_new_7456dc18cc110e9c","AbortController","__wbg_abort_3c64506fb0036132","abort","__wbg_instanceof_Response_ea36d565358a42f7","Response","__wbg_url_6e564c9e212456f8","url","__wbg_status_3a55bb50e744b834","status","__wbg_headers_e4204c6775f7b3b4","__wbg_arrayBuffer_0e2a43f68a8b3e49","arrayBuffer","__wbg_new_4473c9af1cac368b","URL","__wbg_newwithstrandinit_c07f0662ece15bc6","Request","__wbg_now_5fa0ca001e042f8a","now","__wbg_getRandomValues_3e46aa268da0fed1","getRandomValues","__wbg_randomFillSync_59fcc2add91fe7b3","randomFillSync","__wbg_process_f2b73829dbd321da","process","__wbindgen_is_object","__wbg_versions_cd82f79c98672a9f","versions","__wbg_node_ee3f6da4130bd35f","__wbg_modulerequire_0a83c0c31d12d2c7","__wbg_crypto_9e3521ed42436d35","crypto","__wbg_msCrypto_c429c3f8f7a70bb5","msCrypto","__wbindgen_is_function","__wbg_newnoargs_f579424187aa1717","Function","__wbg_next_c7a2a6b012059a5e","next","__wbg_next_dd1a890d37e38d73","__wbg_done_982b1c7ac0cbc69d","done","__wbg_value_2def2d1fb38b02cd","__wbg_iterator_4b9cedbeda0c0e30","Symbol","iterator","__wbg_get_8bbb82393651dd9c","Reflect","__wbg_call_89558c3e96703ca1","__wbg_new_d3138911a89329b0","__wbg_new_55259b13834a484c","__wbg_call_94697a95cb7e239c","__wbg_toString_9b85345d84562096","__wbg_new_4beacc9c71572250","state0","Promise","__wbg_adapter_410","__wbg_resolve_4f8f547f26b30b27","resolve","__wbg_then_a6860c82b90816ca","then","__wbg_then_58a04e42527f52c6","__wbg_self_e23d74ae45fb17d1","self","__wbg_window_b4be7f48b24ac56e","window","__wbg_globalThis_d61b1f48a57191ae","globalThis","__wbg_global_e7669da72fd7f239","global","__wbindgen_is_undefined","__wbg_buffer_5e74a88a1424a2e0","__wbg_newwithbyteoffsetandlength_278ec7532799393a","__wbg_new_e3b800e570795b3c","__wbg_set_5b8081e9d002f0df","__wbg_length_30803400a8f15c59","__wbg_newwithlength_5f4ce114a24dfe1e","__wbg_subarray_a68f835ca2af506f","__wbg_has_3850edde6df9191b","has","__wbg_set_c42875065132a932","__wbg_stringify_f8bfc9e2d1e8b6a0","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_memory","__wbindgen_closure_wrapper716","makeClosure","__wbindgen_closure_wrapper6314","__wbindgen_closure_wrapper6396","exports","originalModule","webpackPolyfill","children","defineProperty","enumerable","l","_classCallCheck","Constructor","TypeError","_defineProperties","target","props","descriptor","configurable","writable","_createClass","protoProps","staticProps"],"mappings":"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","file":"static/js/3.6495536f.chunk.js","sourcesContent":["import * as wasm from './ergo_lib_wasm_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_34(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hbc24939f625e5b84(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_37(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hc293bc616b23f008(arg0, arg1);\n}\n\nfunction __wbg_adapter_40(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h058f54b206302fb3(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* Extracting hints form singed(invalid) Transaction\n* @param {Transaction} signed_transaction\n* @param {ErgoStateContext} state_context\n* @param {ErgoBoxes} boxes_to_spend\n* @param {ErgoBoxes} _data_boxes\n* @param {Propositions} real_propositions\n* @param {Propositions} simulated_propositions\n* @returns {TransactionHintsBag}\n*/\nexport function extract_hints(signed_transaction, state_context, boxes_to_spend, _data_boxes, real_propositions, simulated_propositions) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(signed_transaction, Transaction);\n        var ptr0 = signed_transaction.ptr;\n        signed_transaction.ptr = 0;\n        _assertClass(state_context, ErgoStateContext);\n        _assertClass(boxes_to_spend, ErgoBoxes);\n        _assertClass(_data_boxes, ErgoBoxes);\n        _assertClass(real_propositions, Propositions);\n        var ptr1 = real_propositions.ptr;\n        real_propositions.ptr = 0;\n        _assertClass(simulated_propositions, Propositions);\n        var ptr2 = simulated_propositions.ptr;\n        simulated_propositions.ptr = 0;\n        wasm.extract_hints(retptr, ptr0, state_context.ptr, boxes_to_spend.ptr, _data_boxes.ptr, ptr1, ptr2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return TransactionHintsBag.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4);\n    const mem = getUint32Memory0();\n    for (let i = 0; i < array.length; i++) {\n        mem[ptr / 4 + i] = addHeapObject(array[i]);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n/**\n* Decodes a base16 string into an array of bytes\n* @param {string} data\n* @returns {Uint8Array}\n*/\nexport function base16_decode(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.base16_decode(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Verify that the signature is presented to satisfy SigmaProp conditions.\n* @param {Address} address\n* @param {Uint8Array} message\n* @param {Uint8Array} signature\n* @returns {boolean}\n*/\nexport function verify_signature(address, message, signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(address, Address);\n        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.verify_signature(retptr, address.ptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayI32FromWasm0(ptr, len) {\n    return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* GET on /info endpoint\n* @param {NodeConf} node\n* @returns {Promise<any>}\n*/\nexport function get_info(node) {\n    _assertClass(node, NodeConf);\n    var ptr0 = node.ptr;\n    node.ptr = 0;\n    var ret = wasm.get_info(ptr0);\n    return takeObject(ret);\n}\n\n/**\n* GET on /nipopow/proof/{minChainLength}/{suffixLength}/{headerId} endpoint\n* @param {NodeConf} node\n* @param {number} min_chain_length\n* @param {number} suffix_len\n* @param {BlockId} header_id\n* @returns {Promise<NipopowProof>}\n*/\nexport function get_nipopow_proof_by_header_id(node, min_chain_length, suffix_len, header_id) {\n    _assertClass(node, NodeConf);\n    var ptr0 = node.ptr;\n    node.ptr = 0;\n    _assertClass(header_id, BlockId);\n    var ptr1 = header_id.ptr;\n    header_id.ptr = 0;\n    var ret = wasm.get_nipopow_proof_by_header_id(ptr0, min_chain_length, suffix_len, ptr1);\n    return takeObject(ret);\n}\n\n/**\n* Given a list of seed nodes, search for peer nodes with an active REST API on port 9053.\n*  - `seeds` represents a list of ergo node URLs from which to start peer discovery.\n*  - `max_parallel_requests` represents the maximum number of HTTP requests that can be made in\n*    parallel\n*  - `timeout` represents the amount of time that is spent search for peers. Once the timeout\n*    value is reached, return with the vec of active peers that have been discovered up to that\n*    point in time.\n* @param {(URL)[]} seeds\n* @param {number} max_parallel_requests\n* @param {number} timeout_sec\n* @returns {Promise<PeerUrls>}\n*/\nexport function peer_discovery(seeds, max_parallel_requests, timeout_sec) {\n    var ptr0 = passArrayJsValueToWasm0(seeds, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.peer_discovery(ptr0, len0, max_parallel_requests, timeout_sec);\n    return takeObject(ret);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_410(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__ha4204752be8eb946(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* Network type\n*/\nexport const NetworkPrefix = Object.freeze({\n/**\n* Mainnet\n*/\nMainnet:0,\"0\":\"Mainnet\",\n/**\n* Testnet\n*/\nTestnet:16,\"16\":\"Testnet\", });\n/**\n* Address types\n*/\nexport const AddressTypePrefix = Object.freeze({\n/**\n* 0x01 - Pay-to-PublicKey(P2PK) address\n*/\nP2Pk:1,\"1\":\"P2Pk\",\n/**\n* 0x02 - Pay-to-Script-Hash(P2SH)\n*/\nPay2Sh:2,\"2\":\"Pay2Sh\",\n/**\n* 0x03 - Pay-to-Script(P2S)\n*/\nPay2S:3,\"3\":\"Pay2S\", });\n/**\n* newtype for box registers R4 - R9\n*/\nexport const NonMandatoryRegisterId = Object.freeze({\n/**\n* id for R4 register\n*/\nR4:4,\"4\":\"R4\",\n/**\n* id for R5 register\n*/\nR5:5,\"5\":\"R5\",\n/**\n* id for R6 register\n*/\nR6:6,\"6\":\"R6\",\n/**\n* id for R7 register\n*/\nR7:7,\"7\":\"R7\",\n/**\n* id for R8 register\n*/\nR8:8,\"8\":\"R8\",\n/**\n* id for R9 register\n*/\nR9:9,\"9\":\"R9\", });\n/**\n*\n* * An address is a short string corresponding to some script used to protect a box. Unlike (string-encoded) binary\n* * representation of a script, an address has some useful characteristics:\n* *\n* * - Integrity of an address could be checked., as it is incorporating a checksum.\n* * - A prefix of address is showing network and an address type.\n* * - An address is using an encoding (namely, Base58) which is avoiding similarly l0Oking characters, friendly to\n* * double-clicking and line-breaking in emails.\n* *\n* *\n* *\n* * An address is encoding network type, address type, checksum, and enough information to watch for a particular scripts.\n* *\n* * Possible network types are:\n* * Mainnet - 0x00\n* * Testnet - 0x10\n* *\n* * For an address type, we form content bytes as follows:\n* *\n* * P2PK - serialized (compressed) public key\n* * P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes\n* * P2S  - serialized script\n* *\n* * Address examples for testnet:\n* *\n* * 3   - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN)\n* * ?   - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB)\n* * ?   - P2S (Ms7smJwLGbUAjuWQ)\n* *\n* * for mainnet:\n* *\n* * 9  - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA)\n* * ?  - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg)\n* * ?  - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)\n* *\n* *\n* * Prefix byte = network type + address type\n* *\n* * checksum = blake2b256(prefix byte ++ content bytes)\n* *\n* * address = prefix byte ++ content bytes ++ checksum\n* *\n*\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * Re-create the address from ErgoTree that was built from the address\n    *\n    * At some point in the past a user entered an address from which the ErgoTree was built.\n    * Re-create the address from this ErgoTree.\n    * `tree` - ErgoTree that was created from an Address\n    * @param {ErgoTree} ergo_tree\n    * @returns {Address}\n    */\n    static recreate_from_ergo_tree(ergo_tree) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ergo_tree, ErgoTree);\n            wasm.address_recreate_from_ergo_tree(retptr, ergo_tree.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a P2PK address from serialized PK bytes(EcPoint/GroupElement)\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static p2pk_from_pk_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_p2pk_from_pk_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) testnet address from string, checking that address is from the testnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_testnet_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_testnet_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) mainnet address from string, checking that address is from the mainnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_mainnet_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_mainnet_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) address from string without checking the network prefix\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode (base58) address\n    * @param {number} network_prefix\n    * @returns {string}\n    */\n    to_base58(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_base58(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address (that includes the network prefix)\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode address as serialized bytes (that includes the network prefix)\n    * @param {number} network_prefix\n    * @returns {Uint8Array}\n    */\n    to_bytes(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the type of the address\n    * @returns {number}\n    */\n    address_type_prefix() {\n        var ret = wasm.address_address_type_prefix(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Create an address from a public key\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static from_public_key(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_public_key(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Creates an ErgoTree script from the address\n    * @returns {ErgoTree}\n    */\n    to_ergo_tree() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_ergo_tree(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* BatchMerkleProof type to validate root hash for multiple nodes\n*/\nexport class BatchMerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BatchMerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_batchmerkleproof_free(ptr);\n    }\n    /**\n    * Creates a new [`BatchMerkleProof`] from json representation\n    * @param {any} json\n    * @returns {BatchMerkleProof}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.batchmerkleproof_from_json(retptr, addBorrowedObject(json));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BatchMerkleProof.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Converts [`BatchMerkleProof`] to json representation\n    * @returns {any}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.batchmerkleproof_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Calculates root hash for [`BatchMerkleProof`] and compares it against expected root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.batchmerkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* Block header\n*/\nexport class BlockHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr);\n    }\n    /**\n    * Parse from JSON (Node API)\n    * @param {string} json\n    * @returns {BlockHeader}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockheader_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHeader.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get Header's id\n    * @returns {BlockId}\n    */\n    id() {\n        var ret = wasm.blockheader_id(this.ptr);\n        return BlockId.__wrap(ret);\n    }\n}\n/**\n* Collection of BlockHeaders\n*/\nexport class BlockHeaders {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeaders.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheaders_free(ptr);\n    }\n    /**\n    * parse BlockHeader array from JSON (Node API)\n    * @param {any[]} json_vals\n    * @returns {BlockHeaders}\n    */\n    static from_json(json_vals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockheaders_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHeaders.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create new collection with one element\n    * @param {BlockHeader} b\n    */\n    constructor(b) {\n        _assertClass(b, BlockHeader);\n        var ret = wasm.blockheaders_new(b.ptr);\n        return BlockHeaders.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.blockheaders_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {BlockHeader} b\n    */\n    add(b) {\n        _assertClass(b, BlockHeader);\n        wasm.blockheaders_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {BlockHeader}\n    */\n    get(index) {\n        var ret = wasm.blockheaders_get(this.ptr, index);\n        return BlockHeader.__wrap(ret);\n    }\n}\n/**\n* Block id\n*/\nexport class BlockId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockid_free(ptr);\n    }\n}\n/**\n* Box id (32-byte digest)\n*/\nexport class BoxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxid_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {string} box_id_str\n    * @returns {BoxId}\n    */\n    static from_str(box_id_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(box_id_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.boxid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.boxid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Selected boxes with change boxes (by [`BoxSelector`])\n*/\nexport class BoxSelection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxSelection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxselection_free(ptr);\n    }\n    /**\n    * Create a selection to easily inject custom selection algorithms\n    * @param {ErgoBoxes} boxes\n    * @param {ErgoBoxAssetsDataList} change\n    */\n    constructor(boxes, change) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(boxes, ErgoBoxes);\n            _assertClass(change, ErgoBoxAssetsDataList);\n            wasm.boxselection_new(retptr, boxes.ptr, change.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxSelection.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Selected boxes to spend as transaction inputs\n    * @returns {ErgoBoxes}\n    */\n    boxes() {\n        var ret = wasm.boxselection_boxes(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Selected boxes to use as change\n    * @returns {ErgoBoxAssetsDataList}\n    */\n    change() {\n        var ret = wasm.boxselection_change(this.ptr);\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n}\n/**\n* Box value in nanoERGs with bound checks\n*/\nexport class BoxValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxvalue_free(ptr);\n    }\n    /**\n    * Recommended (safe) minimal box value to use in case box size estimation is unavailable.\n    * Allows box size upto 2777 bytes with current min box value per byte of 360 nanoERGs\n    * @returns {BoxValue}\n    */\n    static SAFE_USER_MIN() {\n        var ret = wasm.boxvalue_SAFE_USER_MIN();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Number of units inside one ERGO (i.e. one ERG using nano ERG representation)\n    * @returns {I64}\n    */\n    static UNITS_PER_ERGO() {\n        var ret = wasm.boxvalue_UNITS_PER_ERGO();\n        return I64.__wrap(ret);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {BoxValue}\n    */\n    static from_i64(v) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(v, I64);\n            wasm.boxvalue_from_i64(retptr, v.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxValue.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.boxvalue_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* CommitmentHint\n*/\nexport class CommitmentHint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CommitmentHint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_commitmenthint_free(ptr);\n    }\n}\n/**\n* Ergo constant(evaluated) values\n*/\nexport class Constant {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Constant.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constant_free(ptr);\n    }\n    /**\n    * Decode from Base16-encoded ErgoTree serialized value\n    * @param {string} base16_bytes_str\n    * @returns {Constant}\n    */\n    static decode_from_base16(base16_bytes_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(base16_bytes_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_decode_from_base16(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode as Base16-encoded ErgoTree serialized value or return an error if serialization\n    * failed\n    * @returns {string}\n    */\n    encode_to_base16() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_encode_to_base16(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if Constant cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i32 value\n    * @param {number} v\n    * @returns {Constant}\n    */\n    static from_i32(v) {\n        var ret = wasm.constant_from_i32(v);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i32 value, returning error if wrong type\n    * @returns {number}\n    */\n    to_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i64\n    * @param {I64} v\n    * @returns {Constant}\n    */\n    static from_i64(v) {\n        _assertClass(v, I64);\n        var ret = wasm.constant_from_i64(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i64 value, returning error if wrong type\n    * @returns {I64}\n    */\n    to_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create BigInt constant from byte array (signed bytes bit-endian)\n    * @param {Uint8Array} num\n    * @returns {Constant}\n    */\n    static from_bigint_signed_bytes_be(num) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(num, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_bigint_signed_bytes_be(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from byte array\n    * @param {Uint8Array} v\n    * @returns {Constant}\n    */\n    static from_byte_array(v) {\n        var ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_byte_array(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract byte array, returning error if wrong type\n    * @returns {Uint8Array}\n    */\n    to_byte_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_byte_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Int]` from integer array\n    * @param {Int32Array} arr\n    * @returns {Constant}\n    */\n    static from_i32_array(arr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray32ToWasm0(arr, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_i32_array(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Int]` as integer array\n    * @returns {Int32Array}\n    */\n    to_i32_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayI32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Long]` from string array\n    * @param {any[]} arr\n    * @returns {Constant}\n    */\n    static from_i64_str_array(arr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_i64_str_array(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Long]` as string array\n    * @returns {any[]}\n    */\n    to_i64_str_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64_str_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Coll[Byte]]` as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    to_coll_coll_byte() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_coll_coll_byte(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Coll[Byte]]` from array byte array\n    * @param {(Uint8Array)[]} arr\n    * @returns {Constant}\n    */\n    static from_coll_coll_byte(arr) {\n        var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_coll_coll_byte(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Parse raw `EcPoint` value from bytes and make `ProveDlog` constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_ecpoint_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parse raw `EcPoint` value from bytes and make `GroupElement` constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes_group_element(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_ecpoint_bytes_group_element(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Coll[Byte], Coll[Byte])` tuple Constant\n    * @param {Uint8Array} bytes1\n    * @param {Uint8Array} bytes2\n    * @returns {Constant}\n    */\n    static from_tuple_coll_bytes(bytes1, bytes2) {\n        var ptr0 = passArray8ToWasm0(bytes1, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(bytes2, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_tuple_coll_bytes(ptr0, len0, ptr1, len1);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Coll[Byte], Coll[Byte])` tuple from Constant as array of Uint8Array\n    * @returns {(Uint8Array)[]}\n    */\n    to_tuple_coll_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_coll_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Int, Int)` tuple Constant\n    * @returns {any[]}\n    */\n    to_tuple_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Long, Long)` tuple Constant\n    * @param {I64} l1\n    * @param {I64} l2\n    * @returns {Constant}\n    */\n    static from_tuple_i64(l1, l2) {\n        _assertClass(l1, I64);\n        _assertClass(l2, I64);\n        var ret = wasm.constant_from_tuple_i64(l1.ptr, l2.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Long, Long)` tuple from Constant as array of strings\n    * @returns {any[]}\n    */\n    to_tuple_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from ErgoBox value\n    * @param {ErgoBox} v\n    * @returns {Constant}\n    */\n    static from_ergo_box(v) {\n        _assertClass(v, ErgoBox);\n        var ret = wasm.constant_from_ergo_box(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract ErgoBox value, returning error if wrong type\n    * @returns {ErgoBox}\n    */\n    to_ergo_box() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_ergo_box(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* User-defined variables to be put into context\n*/\nexport class ContextExtension {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ContextExtension.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contextextension_free(ptr);\n    }\n    /**\n    * Create new ContextExtension instance\n    */\n    constructor() {\n        var ret = wasm.contextextension_new();\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * Set the supplied pair in the ContextExtension\n    * @param {number} id\n    * @param {Constant} value\n    */\n    set_pair(id, value) {\n        _assertClass(value, Constant);\n        wasm.contextextension_set_pair(this.ptr, id, value.ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.contextextension_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * get from map or fail if key is missing\n    * @param {number} key\n    * @returns {Constant}\n    */\n    get(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_get(retptr, this.ptr, key);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns all keys in the map\n    * @returns {Uint8Array}\n    */\n    keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_keys(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ContextExtension cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Defines the contract(script) that will be guarding box contents\n*/\nexport class Contract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Contract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contract_free(ptr);\n    }\n    /**\n    * Create new contract from ErgoTree\n    * @param {ErgoTree} ergo_tree\n    * @returns {Contract}\n    */\n    static new(ergo_tree) {\n        _assertClass(ergo_tree, ErgoTree);\n        var ptr0 = ergo_tree.ptr;\n        ergo_tree.ptr = 0;\n        var ret = wasm.contract_new(ptr0);\n        return Contract.__wrap(ret);\n    }\n    /**\n    * create new contract that allow spending of the guarded box by a given recipient ([`Address`])\n    * @param {Address} recipient\n    * @returns {Contract}\n    */\n    static pay_to_address(recipient) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(recipient, Address);\n            wasm.contract_pay_to_address(retptr, recipient.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Contract.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Compiles a contract from ErgoScript source code\n    * @param {string} source\n    * @returns {Contract}\n    */\n    static compile(source) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(source, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.contract_compile(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Contract.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the ErgoTree of the contract\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.contract_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n}\n/**\n* Inputs, that are used to enrich script context, but won't be spent by the transaction\n*/\nexport class DataInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainput_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {BoxId} box_id\n    */\n    constructor(box_id) {\n        _assertClass(box_id, BoxId);\n        var ptr0 = box_id.ptr;\n        box_id.ptr = 0;\n        var ret = wasm.datainput_new(ptr0);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.datainput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n}\n/**\n* DataInput collection\n*/\nexport class DataInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainputs_free(ptr);\n    }\n    /**\n    * Create empty DataInputs\n    */\n    constructor() {\n        var ret = wasm.datainputs_new();\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.datainputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {DataInput}\n    */\n    get(index) {\n        var ret = wasm.datainputs_get(this.ptr, index);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {DataInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, DataInput);\n        wasm.datainputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* According to\n* BIP-44 <https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki>\n* and EIP-3 <https://github.com/ergoplatform/eips/blob/master/eip-0003.md>\n*/\nexport class DerivationPath {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DerivationPath.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_derivationpath_free(ptr);\n    }\n    /**\n    * Create derivation path for a given account index (hardened) and address indices\n    * `m / 44' / 429' / acc' / 0 / address[0] / address[1] / ...`\n    * or `m / 44' / 429' / acc' / 0` if address indices are empty\n    * change is always zero according to EIP-3\n    * acc is expected as a 31-bit value (32th bit should not be set)\n    * @param {number} acc\n    * @param {Uint32Array} address_indices\n    * @returns {DerivationPath}\n    */\n    static new(acc, address_indices) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray32ToWasm0(address_indices, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.derivationpath_new(retptr, acc, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create root derivation path\n    * @returns {DerivationPath}\n    */\n    static master_path() {\n        var ret = wasm.derivationpath_master_path();\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * Returns the length of the derivation path\n    * @returns {number}\n    */\n    depth() {\n        var ret = wasm.derivationpath_depth(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a new path with the last element of the deriviation path being increased, e.g. m/1/2 -> m/1/3\n    * Returns an empty path error if the path is empty (master node)\n    * @returns {DerivationPath}\n    */\n    next() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_next(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * String representation of derivation path\n    * E.g m/44'/429'/0'/0/1\n    * @returns {string}\n    */\n    toString() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_toString(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Create a derivation path from a formatted string\n    * E.g \"m/44'/429'/0'/0/1\"\n    * @param {string} path\n    * @returns {DerivationPath}\n    */\n    static from_string(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.derivationpath_from_string(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * For 0x21 Sign Transaction command of Ergo Ledger App Protocol\n    * P2PK Sign (0x0D) instruction\n    * Sign calculated TX hash with private key for provided BIP44 path.\n    * Data:\n    *\n    * Field\n    * Size (B)\n    * Description\n    *\n    * BIP32 path length\n    * 1\n    * Value: 0x02-0x0A (2-10). Number of path components\n    *\n    * First derivation index\n    * 4\n    * Big-endian. Value: 44’\n    *\n    * Second derivation index\n    * 4\n    * Big-endian. Value: 429’ (Ergo coin id)\n    *\n    * Optional Third index\n    * 4\n    * Big-endian. Any valid bip44 hardened value.\n    * ...\n    * Optional Last index\n    * 4\n    * Big-endian. Any valid bip44 value.\n    * @returns {Uint8Array}\n    */\n    ledger_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_ledger_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Ergo box, that is taking part in some transaction on the chain\n* Differs with [`ErgoBoxCandidate`] by added transaction id and an index in the input of that transaction\n*/\nexport class ErgoBox {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBox.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergobox_free(ptr);\n    }\n    /**\n    * make a new box with:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * `tx_id` - transaction id in which this box was \"created\" (participated in outputs)\n    * `index` - index (in outputs) in the transaction\n    * @param {BoxValue} value\n    * @param {number} creation_height\n    * @param {Contract} contract\n    * @param {TxId} tx_id\n    * @param {number} index\n    * @param {Tokens} tokens\n    */\n    constructor(value, creation_height, contract, tx_id, index, tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(value, BoxValue);\n            _assertClass(contract, Contract);\n            _assertClass(tx_id, TxId);\n            _assertClass(tokens, Tokens);\n            wasm.ergobox_new(retptr, value.ptr, creation_height, contract.ptr, tx_id.ptr, index, tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.ergobox_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get id of transaction which created the box\n    * @returns {TxId}\n    */\n    tx_id() {\n        var ret = wasm.ergobox_tx_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Index of this box in transaction outputs\n    * @returns {number}\n    */\n    index() {\n        var ret = wasm.ergobox_index(this.ptr);\n        return ret;\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergobox_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergobox_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergobox_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergobox_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergobox_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amounts encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {ErgoBox}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergobox_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Serialized additional register as defined in ErgoBox serialization (registers count,\n    * followed by every non-empyt register value serialized)\n    * @returns {Uint8Array}\n    */\n    serialized_additional_registers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_serialized_additional_registers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ErgoBox or fails with error\n    * @param {Uint8Array} data\n    * @returns {ErgoBox}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergobox_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Pair of <value, tokens> for an box\n*/\nexport class ErgoBoxAssetsData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdata_free(ptr);\n    }\n    /**\n    * Create new instance\n    * @param {BoxValue} value\n    * @param {Tokens} tokens\n    */\n    constructor(value, tokens) {\n        _assertClass(value, BoxValue);\n        _assertClass(tokens, Tokens);\n        var ret = wasm.ergoboxassetsdata_new(value.ptr, tokens.ptr);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Value part of the box\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxassetsdata_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Tokens part of the box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxassetsdata_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n}\n/**\n* List of asset data for a box\n*/\nexport class ErgoBoxAssetsDataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsDataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdatalist_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.ergoboxassetsdatalist_new();\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxassetsdatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxAssetsData}\n    */\n    get(index) {\n        var ret = wasm.ergoboxassetsdatalist_get(this.ptr, index);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {ErgoBoxAssetsData} elem\n    */\n    add(elem) {\n        _assertClass(elem, ErgoBoxAssetsData);\n        wasm.ergoboxassetsdatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ErgoBox candidate not yet included in any transaction on the chain\n*/\nexport class ErgoBoxCandidate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidate_free(ptr);\n    }\n    /**\n    * Create a box with miner's contract and given value\n    * @param {BoxValue} fee_amount\n    * @param {number} creation_height\n    * @returns {ErgoBoxCandidate}\n    */\n    static new_miner_fee_box(fee_amount, creation_height) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(fee_amount, BoxValue);\n            wasm.ergoboxcandidate_new_miner_fee_box(retptr, fee_amount.ptr, creation_height);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxCandidate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidate_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergoboxcandidate_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxcandidate_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergoboxcandidate_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidate_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n}\n/**\n* ErgoBoxCandidate builder\n*/\nexport class ErgoBoxCandidateBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidateBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidatebuilder_free(ptr);\n    }\n    /**\n    * Create builder with required box parameters:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * It should not exceed height of the block, containing the transaction with this box.\n    * @param {BoxValue} value\n    * @param {Contract} contract\n    * @param {number} creation_height\n    */\n    constructor(value, contract, creation_height) {\n        _assertClass(value, BoxValue);\n        _assertClass(contract, Contract);\n        var ret = wasm.ergoboxcandidatebuilder_new(value.ptr, contract.ptr, creation_height);\n        return ErgoBoxCandidateBuilder.__wrap(ret);\n    }\n    /**\n    * Set minimal value (per byte of the serialized box size)\n    * @param {number} new_min_value_per_byte\n    */\n    set_min_box_value_per_byte(new_min_value_per_byte) {\n        wasm.ergoboxcandidatebuilder_set_min_box_value_per_byte(this.ptr, new_min_value_per_byte);\n    }\n    /**\n    * Get minimal value (per byte of the serialized box size)\n    * @returns {number}\n    */\n    min_box_value_per_byte() {\n        var ret = wasm.ergoboxcandidatebuilder_min_box_value_per_byte(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Set new box value\n    * @param {BoxValue} new_value\n    */\n    set_value(new_value) {\n        _assertClass(new_value, BoxValue);\n        var ptr0 = new_value.ptr;\n        new_value.ptr = 0;\n        wasm.ergoboxcandidatebuilder_set_value(this.ptr, ptr0);\n    }\n    /**\n    * Get box value\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidatebuilder_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Calculate serialized box size(in bytes)\n    * @returns {number}\n    */\n    calc_box_size_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_calc_box_size_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Calculate minimal box value for the current box serialized size(in bytes)\n    * @returns {BoxValue}\n    */\n    calc_min_box_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_calc_min_box_value(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxValue.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set register with a given id (R4-R9) to the given value\n    * @param {number} register_id\n    * @param {Constant} value\n    */\n    set_register_value(register_id, value) {\n        _assertClass(value, Constant);\n        wasm.ergoboxcandidatebuilder_set_register_value(this.ptr, register_id, value.ptr);\n    }\n    /**\n    * Returns register value for the given register id (R4-R9), or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidatebuilder_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Delete register value(make register empty) for the given register id (R4-R9)\n    * @param {number} register_id\n    */\n    delete_register_value(register_id) {\n        wasm.ergoboxcandidatebuilder_delete_register_value(this.ptr, register_id);\n    }\n    /**\n    * Mint token, as defined in <https://github.com/ergoplatform/eips/blob/master/eip-0004.md>\n    * `token` - token id(box id of the first input box in transaction) and token amount,\n    * `token_name` - token name (will be encoded in R4),\n    * `token_desc` - token description (will be encoded in R5),\n    * `num_decimals` - number of decimals (will be encoded in R6)\n    * @param {Token} token\n    * @param {string} token_name\n    * @param {string} token_desc\n    * @param {number} num_decimals\n    */\n    mint_token(token, token_name, token_desc, num_decimals) {\n        _assertClass(token, Token);\n        var ptr0 = passStringToWasm0(token_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(token_desc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.ergoboxcandidatebuilder_mint_token(this.ptr, token.ptr, ptr0, len0, ptr1, len1, num_decimals);\n    }\n    /**\n    * Add given token id and token amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    add_token(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        wasm.ergoboxcandidatebuilder_add_token(this.ptr, token_id.ptr, amount.ptr);\n    }\n    /**\n    * Build the box candidate\n    * @returns {ErgoBoxCandidate}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_build(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxCandidate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Collection of ErgoBoxCandidates\n*/\nexport class ErgoBoxCandidates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidates_free(ptr);\n    }\n    /**\n    * Create new outputs\n    * @param {ErgoBoxCandidate} box_candidate\n    */\n    constructor(box_candidate) {\n        _assertClass(box_candidate, ErgoBoxCandidate);\n        var ret = wasm.ergoboxcandidates_new(box_candidate.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * sometimes it's useful to keep track of an empty list\n    * but keep in mind Ergo transactions need at least 1 output\n    * @returns {ErgoBoxCandidates}\n    */\n    static empty() {\n        var ret = wasm.ergoboxcandidates_empty();\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxcandidates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxCandidate}\n    */\n    get(index) {\n        var ret = wasm.ergoboxcandidates_get(this.ptr, index);\n        return ErgoBoxCandidate.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBoxCandidate} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBoxCandidate);\n        wasm.ergoboxcandidates_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Collection of ErgoBox'es\n*/\nexport class ErgoBoxes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxes_free(ptr);\n    }\n    /**\n    * parse ErgoBox array from json\n    * @param {any[]} json_vals\n    * @returns {ErgoBoxes}\n    */\n    static from_boxes_json(json_vals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergoboxes_from_boxes_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create new collection with one element\n    * @param {ErgoBox} b\n    */\n    constructor(b) {\n        _assertClass(b, ErgoBox);\n        var ret = wasm.ergoboxes_new(b.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBox} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBox);\n        wasm.ergoboxes_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBox}\n    */\n    get(index) {\n        var ret = wasm.ergoboxes_get(this.ptr, index);\n        return ErgoBox.__wrap(ret);\n    }\n    /**\n    * Empty ErgoBoxes\n    * @returns {ErgoBoxes}\n    */\n    static empty() {\n        var ret = wasm.ergoboxes_empty();\n        return ErgoBoxes.__wrap(ret);\n    }\n}\n/**\n* Blockchain state (last headers, etc.)\n*/\nexport class ErgoStateContext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoStateContext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergostatecontext_free(ptr);\n    }\n    /**\n    * Create new context from pre-header\n    * @param {PreHeader} pre_header\n    * @param {BlockHeaders} headers\n    */\n    constructor(pre_header, headers) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(pre_header, PreHeader);\n            var ptr0 = pre_header.ptr;\n            pre_header.ptr = 0;\n            _assertClass(headers, BlockHeaders);\n            var ptr1 = headers.ptr;\n            headers.ptr = 0;\n            wasm.ergostatecontext_new(retptr, ptr0, ptr1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoStateContext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* The root of ErgoScript IR. Serialized instances of this class are self sufficient and can be passed around.\n*/\nexport class ErgoTree {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoTree.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergotree_free(ptr);\n    }\n    /**\n    * Decode from base16 encoded serialized ErgoTree\n    * @param {string} s\n    * @returns {ErgoTree}\n    */\n    static from_base16_bytes(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergotree_from_base16_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode from encoded serialized ErgoTree\n    * @param {Uint8Array} data\n    * @returns {ErgoTree}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergotree_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ErgoTree cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns Base16-encoded serialized bytes\n    * @returns {string}\n    */\n    to_base16_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_to_base16_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Returns constants number as stored in serialized ErgoTree or error if the parsing of\n    * constants is failed\n    * @returns {number}\n    */\n    constants_len() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_constants_len(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns constant with given index (as stored in serialized ErgoTree)\n    * or None if index is out of bounds\n    * or error if constants parsing were failed\n    * @param {number} index\n    * @returns {Constant | undefined}\n    */\n    get_constant(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_get_constant(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 === 0 ? undefined : Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Consumes the calling ErgoTree and returns new ErgoTree with a new constant value\n    * for a given index in constants list (as stored in serialized ErgoTree), or an error.\n    * After the call the calling ErgoTree will be null.\n    * @param {number} index\n    * @param {Constant} constant\n    * @returns {ErgoTree}\n    */\n    with_constant(index, constant) {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(constant, Constant);\n            wasm.ergotree_with_constant(retptr, ptr, index, constant.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Serialized proposition expression of SigmaProp type with\n    * ConstantPlaceholder nodes instead of Constant nodes\n    * @returns {Uint8Array}\n    */\n    template_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_template_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented public key implemented according to BIP-32\n*/\nexport class ExtPubKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtPubKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extpubkey_free(ptr);\n    }\n    /**\n    * Create ExtPubKey from public key bytes (from SEC1 compressed), chain code and derivation\n    * path\n    * @param {Uint8Array} public_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtPubKey}\n    */\n    static new(public_key_bytes, chain_code, derivation_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(public_key_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            _assertClass(derivation_path, DerivationPath);\n            wasm.extpubkey_new(retptr, ptr0, len0, ptr1, len1, derivation_path.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Soft derivation of the child public key with a given index\n    * index is expected to be a 31-bit value(32th bit should not be set)\n    * @param {number} index\n    * @returns {ExtPubKey}\n    */\n    child(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_child(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended pub key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtPubKey}\n    */\n    derive(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(path, DerivationPath);\n            var ptr0 = path.ptr;\n            path.ptr = 0;\n            wasm.extpubkey_derive(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create address (P2PK) from this extended public key\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.extpubkey_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Chain code of the `ExtPubKey`\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Public key bytes of the `ExtPubKey`\n    * @returns {Uint8Array}\n    */\n    pub_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_pub_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented secret key implemented according to BIP-32\n*/\nexport class ExtSecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtSecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extsecretkey_free(ptr);\n    }\n    /**\n    * Create ExtSecretKey from secret key bytes, chain code and derivation path\n    * @param {Uint8Array} secret_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtSecretKey}\n    */\n    static new(secret_key_bytes, chain_code, derivation_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(secret_key_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            _assertClass(derivation_path, DerivationPath);\n            wasm.extsecretkey_new(retptr, ptr0, len0, ptr1, len1, derivation_path.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive root extended secret key\n    * @param {Uint8Array} seed_bytes\n    * @returns {ExtSecretKey}\n    */\n    static derive_master(seed_bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(seed_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.extsecretkey_derive_master(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended secret key from the provided index\n    * The index is in the form of soft or hardened indices\n    * For example: 4 or 4' respectively\n    * @param {string} index\n    * @returns {ExtSecretKey}\n    */\n    child(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(index, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.extsecretkey_child(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended secret key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtSecretKey}\n    */\n    derive(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(path, DerivationPath);\n            var ptr0 = path.ptr;\n            path.ptr = 0;\n            wasm.extsecretkey_derive(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The bytes of the associated secret key\n    * @returns {Uint8Array}\n    */\n    secret_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_secret_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The extended public key associated with this secret key\n    * @returns {ExtPubKey}\n    */\n    public_key() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_public_key(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derivation path associated with the ext secret key\n    * @returns {DerivationPath}\n    */\n    path() {\n        var ret = wasm.extsecretkey_path(this.ptr);\n        return DerivationPath.__wrap(ret);\n    }\n}\n/**\n* HintsBag\n*/\nexport class HintsBag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HintsBag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_hintsbag_free(ptr);\n    }\n    /**\n    * Empty HintsBag\n    * @returns {HintsBag}\n    */\n    static empty() {\n        var ret = wasm.hintsbag_empty();\n        return HintsBag.__wrap(ret);\n    }\n    /**\n    * Add commitment hint to the bag\n    * @param {CommitmentHint} hint\n    */\n    add_commitment(hint) {\n        _assertClass(hint, CommitmentHint);\n        var ptr0 = hint.ptr;\n        hint.ptr = 0;\n        wasm.hintsbag_add_commitment(this.ptr, ptr0);\n    }\n    /**\n    * Length of HintsBag\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.hintsbag_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get commitment\n    * @param {number} index\n    * @returns {CommitmentHint}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hintsbag_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitmentHint.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Wrapper for i64 for JS/TS\n*/\nexport class I64 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(I64.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_i64_free(ptr);\n    }\n    /**\n    * Create from a standard rust string representation\n    * @param {string} string\n    * @returns {I64}\n    */\n    static from_str(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.i64_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * String representation of the value for use from environments that don't support i64\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.i64_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Get the value as JS number (64-bit float)\n    * @returns {number}\n    */\n    as_num() {\n        var ret = wasm.i64_as_num(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Addition with overflow check\n    * @param {I64} other\n    * @returns {I64}\n    */\n    checked_add(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, I64);\n            wasm.i64_checked_add(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Signed inputs used in signed transactions\n*/\nexport class Input {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Input.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_input_free(ptr);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.input_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get the spending proof\n    * @returns {ProverResult}\n    */\n    spending_proof() {\n        var ret = wasm.input_spending_proof(this.ptr);\n        return ProverResult.__wrap(ret);\n    }\n}\n/**\n* Collection of signed inputs\n*/\nexport class Inputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Inputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputs_free(ptr);\n    }\n    /**\n    * Create empty Inputs\n    */\n    constructor() {\n        var ret = wasm.inputs_new();\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.inputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Input}\n    */\n    get(index) {\n        var ret = wasm.inputs_get(this.ptr, index);\n        return Input.__wrap(ret);\n    }\n}\n/**\n* A level node in a merkle proof\n*/\nexport class LevelNode {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LevelNode.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_levelnode_free(ptr);\n    }\n    /**\n    * Creates a new LevelNode from a 32 byte hash and side that the node belongs on in the tree. Fails if the digest is not 32 bytes\n    * @param {Uint8Array} hash\n    * @param {number} side\n    * @returns {LevelNode}\n    */\n    static new(hash, side) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.levelnode_new(retptr, ptr0, len0, side);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return LevelNode.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated digest (hash) with this node. Returns an empty array if there's no hash\n    * @returns {Uint8Array}\n    */\n    get digest() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.levelnode_digest(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated side with this node (0 = Left, 1 = Right)\n    * @returns {number}\n    */\n    get side() {\n        var ret = wasm.levelnode_side(this.ptr);\n        return ret;\n    }\n}\n/**\n* A MerkleProof type. Given leaf data and levels (bottom-upwards), the root hash can be computed and validated\n*/\nexport class MerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merkleproof_free(ptr);\n    }\n    /**\n    * Creates a new merkle proof with given leaf data and level data (bottom-upwards)\n    * You can verify it against a Blakeb256 root hash by using [`Self::valid()`]\n    * Add a node by using [`Self::add_node()`]\n    * Each digest on the level must be exactly 32 bytes\n    * @param {Uint8Array} leaf_data\n    * @returns {MerkleProof}\n    */\n    static new(leaf_data) {\n        var ptr0 = passArray8ToWasm0(leaf_data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_new(ptr0, len0);\n        return MerkleProof.__wrap(ret);\n    }\n    /**\n    * Adds a new node to the MerkleProof above the current nodes\n    * @param {LevelNode} level\n    */\n    add_node(level) {\n        _assertClass(level, LevelNode);\n        wasm.merkleproof_add_node(this.ptr, level.ptr);\n    }\n    /**\n    * Validates the Merkle proof against the root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* helper methods to get the fee address for various networks\n*/\nexport class MinerAddress {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mineraddress_free(ptr);\n    }\n    /**\n    * address to use in mainnet for the fee\n    * @returns {string}\n    */\n    static mainnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_mainnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * address to use in testnet for the fee\n    * @returns {string}\n    */\n    static testnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_testnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n* Mnemonic\n*/\nexport class Mnemonic {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mnemonic_free(ptr);\n    }\n    /**\n    * Convert a mnemonic phrase into a mnemonic seed\n    * mnemonic_pass is optional and is used to salt the seed\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Uint8Array}\n    */\n    static to_seed(mnemonic_phrase, mnemonic_pass) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.mnemonic_to_seed(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v2 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Combination of an Address with a network\n* These two combined together form a base58 encoding\n*/\nexport class NetworkAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkaddress_free(ptr);\n    }\n    /**\n    * create a new NetworkAddress(address + network prefix) for a given network type\n    * @param {number} network\n    * @param {Address} address\n    * @returns {NetworkAddress}\n    */\n    static new(network, address) {\n        _assertClass(address, Address);\n        var ret = wasm.networkaddress_new(network, address.ptr);\n        return NetworkAddress.__wrap(ret);\n    }\n    /**\n    * Decode (base58) a NetworkAddress (address + network prefix) from string\n    * @param {string} s\n    * @returns {NetworkAddress}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.networkaddress_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode (base58) address\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address\n    * @param {Uint8Array} data\n    * @returns {NetworkAddress}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.networkaddress_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode address as serialized bytes\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Network for the address\n    * @returns {number}\n    */\n    network() {\n        var ret = wasm.networkaddress_network(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get address without network information\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.networkaddress_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n}\n/**\n* A structure representing NiPoPow proof.\n*/\nexport class NipopowProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NipopowProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nipopowproof_free(ptr);\n    }\n}\n/**\n* A verifier for PoPoW proofs. During its lifetime, it processes many proofs with the aim of\n* deducing at any given point what is the best (sub)chain rooted at the specified genesis.\n*/\nexport class NipopowVerifier {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nipopowverifier_free(ptr);\n    }\n}\n/**\n* Node configuration\n*/\nexport class NodeConf {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NodeConf.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nodeconf_free(ptr);\n    }\n    /**\n    * Create a node configuration\n    * addr - a string in a format 'ip_address:port'\n    * @param {string} addr\n    */\n    constructor(addr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.nodeconf_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NodeConf.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* List of peer urls returned from `peer_discovery`. We need this wrapper struct because the\n* `wasm_bindgen` macro currently cannot deal with `Result<Box<[T]>, JsValue>`, for any value `T`\n* that can be converted into a `JsValue` (`Result<Box<[web_sys::Url]>, JsValue>` would be a\n* convenient return type for `peer_discovery`).\n*/\nexport class PeerUrls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PeerUrls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_peerurls_free(ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.peerurls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {URL}\n    */\n    get(index) {\n        var ret = wasm.peerurls_get(this.ptr, index);\n        return takeObject(ret);\n    }\n}\n/**\n* PoPowHeader structure. Represents the block header and unpacked interlinks\n*/\nexport class PoPowHeader {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_popowheader_free(ptr);\n    }\n    /**\n    * Returns block header\n    * @returns {BlockHeader}\n    */\n    header() {\n        var ret = wasm.popowheader_header(this.ptr);\n        return BlockHeader.__wrap(ret);\n    }\n    /**\n    * Returns interlinks for PoPowHeader\n    * @returns {any}\n    */\n    interlinks() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.popowheader_interlinks(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns interlinks proof [`crate::batchmerkleproof::BatchMerkleProof`]\n    * @returns {BatchMerkleProof}\n    */\n    interlinks_proof() {\n        var ret = wasm.popowheader_interlinks_proof(this.ptr);\n        return BatchMerkleProof.__wrap(ret);\n    }\n    /**\n    * Validates interlinks merkle root with compact merkle multiproof. See [`PoPowHeader::interlinks_proof`] for BatchMerkleProof access\n    * @returns {boolean}\n    */\n    check_interlinks_proof() {\n        var ret = wasm.popowheader_check_interlinks_proof(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Returns block height for Header\n    * @returns {number}\n    */\n    height() {\n        var ret = wasm.popowheader_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns Block ID for Header\n    * @returns {BlockId}\n    */\n    id() {\n        var ret = wasm.popowheader_id(this.ptr);\n        return BlockId.__wrap(ret);\n    }\n}\n/**\n* Block header with the current `spendingTransaction`, that can be predicted\n* by a miner before it's formation\n*/\nexport class PreHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PreHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_preheader_free(ptr);\n    }\n    /**\n    * Create using data from block header\n    * @param {BlockHeader} block_header\n    * @returns {PreHeader}\n    */\n    static from_block_header(block_header) {\n        _assertClass(block_header, BlockHeader);\n        var ptr0 = block_header.ptr;\n        block_header.ptr = 0;\n        var ret = wasm.preheader_from_block_header(ptr0);\n        return PreHeader.__wrap(ret);\n    }\n}\n/**\n* Propositions list(public keys)\n*/\nexport class Propositions {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Propositions.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_propositions_free(ptr);\n    }\n    /**\n    * Create empty proposition holder\n    */\n    constructor() {\n        var ret = wasm.propositions_new();\n        return Propositions.__wrap(ret);\n    }\n    /**\n    * Adding new proposition\n    * @param {Uint8Array} proposition\n    */\n    add_proposition_from_byte(proposition) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(proposition, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.propositions_add_proposition_from_byte(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Proof of correctness of tx spending\n*/\nexport class ProverResult {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProverResult.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proverresult_free(ptr);\n    }\n    /**\n    * Get proof\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.proverresult_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n}\n/**\n* Represent `reduced` transaction, i.e. unsigned transaction where each unsigned input\n* is augmented with ReducedInput which contains a script reduction result.\n* After an unsigned transaction is reduced it can be signed without context.\n* Thus, it can be serialized and transferred for example to Cold Wallet and signed\n* in an environment where secrets are known.\n* see EIP-19 for more details -\n* <https://github.com/ergoplatform/eips/blob/f280890a4163f2f2e988a0091c078e36912fc531/eip-0019.md>\n*/\nexport class ReducedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ReducedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_reducedtransaction_free(ptr);\n    }\n    /**\n    * Returns `reduced` transaction, i.e. unsigned transaction where each unsigned input\n    * is augmented with ReducedInput which contains a script reduction result.\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {ErgoStateContext} state_context\n    * @returns {ReducedTransaction}\n    */\n    static from_unsigned_tx(unsigned_tx, boxes_to_spend, data_boxes, state_context) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(unsigned_tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            _assertClass(state_context, ErgoStateContext);\n            wasm.reducedtransaction_from_unsigned_tx(retptr, unsigned_tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, state_context.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ReducedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reducedtransaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ReducedTransaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {ReducedTransaction}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.reducedtransaction_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ReducedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    unsigned_tx() {\n        var ret = wasm.reducedtransaction_unsigned_tx(this.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n}\n/**\n* Secret key for the prover\n*/\nexport class SecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr);\n    }\n    /**\n    * generate random key\n    * @returns {SecretKey}\n    */\n    static random_dlog() {\n        var ret = wasm.secretkey_random_dlog();\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Parse dlog secret key from bytes (SEC-1-encoded scalar)\n    * @param {Uint8Array} bytes\n    * @returns {SecretKey}\n    */\n    static dlog_from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_dlog_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Address (encoded public image)\n    * @returns {Address}\n    */\n    get_address() {\n        var ret = wasm.secretkey_get_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Encode from a serialized key\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* SecretKey collection\n*/\nexport class SecretKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkeys_free(ptr);\n    }\n    /**\n    * Create empty SecretKeys\n    */\n    constructor() {\n        var ret = wasm.secretkeys_new();\n        return SecretKeys.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.secretkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {SecretKey}\n    */\n    get(index) {\n        var ret = wasm.secretkeys_get(this.ptr, index);\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {SecretKey} elem\n    */\n    add(elem) {\n        _assertClass(elem, SecretKey);\n        wasm.secretkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* Naive box selector, collects inputs until target balance is reached\n*/\nexport class SimpleBoxSelector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SimpleBoxSelector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_simpleboxselector_free(ptr);\n    }\n    /**\n    * Create empty SimpleBoxSelector\n    */\n    constructor() {\n        var ret = wasm.simpleboxselector_new();\n        return SimpleBoxSelector.__wrap(ret);\n    }\n    /**\n    * Selects inputs to satisfy target balance and tokens.\n    * `inputs` - available inputs (returns an error, if empty),\n    * `target_balance` - coins (in nanoERGs) needed,\n    * `target_tokens` - amount of tokens needed.\n    * Returns selected inputs and box assets(value+tokens) with change.\n    * @param {ErgoBoxes} inputs\n    * @param {BoxValue} target_balance\n    * @param {Tokens} target_tokens\n    * @returns {BoxSelection}\n    */\n    select(inputs, target_balance, target_tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, ErgoBoxes);\n            _assertClass(target_balance, BoxValue);\n            _assertClass(target_tokens, Tokens);\n            wasm.simpleboxselector_select(retptr, this.ptr, inputs.ptr, target_balance.ptr, target_tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxSelection.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token represented with token id paired with it's amount\n*/\nexport class Token {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Token.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_token_free(ptr);\n    }\n    /**\n    * Create a token with given token id and amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    constructor(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        var ret = wasm.token_new(token_id.ptr, amount.ptr);\n        return Token.__wrap(ret);\n    }\n    /**\n    * Get token id\n    * @returns {TokenId}\n    */\n    id() {\n        var ret = wasm.token_id(this.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Get token amount\n    * @returns {TokenAmount}\n    */\n    amount() {\n        var ret = wasm.token_amount(this.ptr);\n        return TokenAmount.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with token amount encoding as string)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token amount with bound checks\n*/\nexport class TokenAmount {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenAmount.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenamount_free(ptr);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {TokenAmount}\n    */\n    static from_i64(v) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(v, I64);\n            wasm.tokenamount_from_i64(retptr, v.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TokenAmount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.tokenamount_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenamount_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token id (32 byte digest)\n*/\nexport class TokenId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenid_free(ptr);\n    }\n    /**\n    * Create token id from ergo box id (32 byte digest)\n    * @param {BoxId} box_id\n    * @returns {TokenId}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.tokenid_from_box_id(box_id.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Parse token id (32 byte digest) from base16-encoded string\n    * @param {string} str\n    * @returns {TokenId}\n    */\n    static from_str(str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.tokenid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TokenId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.tokenid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Array of tokens\n*/\nexport class Tokens {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Tokens.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokens_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.tokens_new();\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.tokens_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Token}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokens_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Token.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {Token} elem\n    */\n    add(elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Token);\n            wasm.tokens_add(retptr, this.ptr, elem.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*\n* * ErgoTransaction is an atomic state transition operation. It destroys Boxes from the state\n* * and creates new ones. If transaction is spending boxes protected by some non-trivial scripts,\n* * its inputs should also contain proof of spending correctness - context extension (user-defined\n* * key-value map) and data inputs (links to existing boxes in the state) that may be used during\n* * script reduction to crypto, signatures that satisfies the remaining cryptographic protection\n* * of the script.\n* * Transactions are not encrypted, so it is possible to browse and view every transaction ever\n* * collected into a block.\n*\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create Transaction from UnsignedTransaction and an array of proofs in the same order as\n    * UnsignedTransaction.inputs with empty proof indicated with empty byte array\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {(Uint8Array)[]} proofs\n    * @returns {Transaction}\n    */\n    static from_unsigned_tx(unsigned_tx, proofs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(unsigned_tx, UnsignedTransaction);\n            var ptr0 = unsigned_tx.ptr;\n            unsigned_tx.ptr = 0;\n            var ptr1 = passArrayJsValueToWasm0(proofs, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transaction_from_unsigned_tx(retptr, ptr0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.transaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {Transaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Inputs for transaction\n    * @returns {Inputs}\n    */\n    inputs() {\n        var ret = wasm.transaction_inputs(this.ptr);\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.transaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.transaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns ErgoBox's created from ErgoBoxCandidate's with tx id and indices\n    * @returns {ErgoBoxes}\n    */\n    outputs() {\n        var ret = wasm.transaction_outputs(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses Transaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {Transaction}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transaction_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* TransactionHintsBag\n*/\nexport class TransactionHintsBag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHintsBag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhintsbag_free(ptr);\n    }\n    /**\n    * Empty TransactionHintsBag\n    * @returns {TransactionHintsBag}\n    */\n    static empty() {\n        var ret = wasm.transactionhintsbag_empty();\n        return TransactionHintsBag.__wrap(ret);\n    }\n    /**\n    * Adding hints for input\n    * @param {number} index\n    * @param {HintsBag} hints_bag\n    */\n    add_hints_for_input(index, hints_bag) {\n        _assertClass(hints_bag, HintsBag);\n        wasm.transactionhintsbag_add_hints_for_input(this.ptr, index, hints_bag.ptr);\n    }\n    /**\n    * Outputting HintsBag corresponding for an input index\n    * @param {number} index\n    * @returns {HintsBag}\n    */\n    all_hints_for_input(index) {\n        var ret = wasm.transactionhintsbag_all_hints_for_input(this.ptr, index);\n        return HintsBag.__wrap(ret);\n    }\n}\n/**\n* Unsigned transaction builder\n*/\nexport class TxBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txbuilder_free(ptr);\n    }\n    /**\n    * Suggested transaction fee (semi-default value used across wallets and dApps as of Oct 2020)\n    * @returns {BoxValue}\n    */\n    static SUGGESTED_TX_FEE() {\n        var ret = wasm.txbuilder_SUGGESTED_TX_FEE();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Creates new TxBuilder\n    * `box_selection` - selected input boxes (via [`super::box_selector`])\n    * `output_candidates` - output boxes to be \"created\" in this transaction,\n    * `current_height` - chain height that will be used in additionally created boxes (change, miner's fee, etc.),\n    * `fee_amount` - miner's fee,\n    * `change_address` - change (inputs - outputs) will be sent to this address,\n    * `min_change_value` - minimal value of the change to be sent to `change_address`, value less than that\n    * will be given to miners,\n    * @param {BoxSelection} box_selection\n    * @param {ErgoBoxCandidates} output_candidates\n    * @param {number} current_height\n    * @param {BoxValue} fee_amount\n    * @param {Address} change_address\n    * @param {BoxValue} min_change_value\n    * @returns {TxBuilder}\n    */\n    static new(box_selection, output_candidates, current_height, fee_amount, change_address, min_change_value) {\n        _assertClass(box_selection, BoxSelection);\n        _assertClass(output_candidates, ErgoBoxCandidates);\n        _assertClass(fee_amount, BoxValue);\n        _assertClass(change_address, Address);\n        _assertClass(min_change_value, BoxValue);\n        var ret = wasm.txbuilder_new(box_selection.ptr, output_candidates.ptr, current_height, fee_amount.ptr, change_address.ptr, min_change_value.ptr);\n        return TxBuilder.__wrap(ret);\n    }\n    /**\n    * Set transaction's data inputs\n    * @param {DataInputs} data_inputs\n    */\n    set_data_inputs(data_inputs) {\n        _assertClass(data_inputs, DataInputs);\n        wasm.txbuilder_set_data_inputs(this.ptr, data_inputs.ptr);\n    }\n    /**\n    * Set context extension for a given input\n    * @param {BoxId} box_id\n    * @param {ContextExtension} context_extension\n    */\n    set_context_extension(box_id, context_extension) {\n        _assertClass(box_id, BoxId);\n        _assertClass(context_extension, ContextExtension);\n        wasm.txbuilder_set_context_extension(this.ptr, box_id.ptr, context_extension.ptr);\n    }\n    /**\n    * Build the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txbuilder_build(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get box selection\n    * @returns {BoxSelection}\n    */\n    box_selection() {\n        var ret = wasm.txbuilder_box_selection(this.ptr);\n        return BoxSelection.__wrap(ret);\n    }\n    /**\n    * Get data inputs\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.txbuilder_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Get outputs EXCLUDING fee and change\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.txbuilder_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Get current height\n    * @returns {number}\n    */\n    current_height() {\n        var ret = wasm.txbuilder_current_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get fee amount\n    * @returns {BoxValue}\n    */\n    fee_amount() {\n        var ret = wasm.txbuilder_fee_amount(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Get change address\n    * @returns {Address}\n    */\n    change_address() {\n        var ret = wasm.txbuilder_change_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Get min change value\n    * @returns {BoxValue}\n    */\n    min_change_value() {\n        var ret = wasm.txbuilder_min_change_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n}\n/**\n* Transaction id\n*/\nexport class TxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txid_free(ptr);\n    }\n    /**\n    * Zero (empty) transaction id (to use as dummy value in tests)\n    * @returns {TxId}\n    */\n    static zero() {\n        var ret = wasm.txid_zero();\n        return TxId.__wrap(ret);\n    }\n    /**\n    * get the tx id as bytes\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * convert a hex string into a TxId\n    * @param {string} s\n    * @returns {TxId}\n    */\n    static from_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.txid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TxId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Unsigned inputs used in constructing unsigned transactions\n*/\nexport class UnsignedInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinput_free(ptr);\n    }\n    /**\n    * Create new unsigned input instance from box id and extension\n    * @param {BoxId} box_id\n    * @param {ContextExtension} ext\n    */\n    constructor(box_id, ext) {\n        _assertClass(box_id, BoxId);\n        _assertClass(ext, ContextExtension);\n        var ret = wasm.unsignedinput_new(box_id.ptr, ext.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Create a new unsigned input from the provided box id\n    * using an empty context extension\n    * @param {BoxId} box_id\n    * @returns {UnsignedInput}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.unsignedinput_from_box_id(box_id.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.unsignedinput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.unsignedinput_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n}\n/**\n* Collection of unsigned signed inputs\n*/\nexport class UnsignedInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinputs_free(ptr);\n    }\n    /**\n    * Create empty UnsignedInputs\n    */\n    constructor() {\n        var ret = wasm.unsignedinputs_new();\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.unsignedinputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {UnsignedInput}\n    */\n    get(index) {\n        var ret = wasm.unsignedinputs_get(this.ptr, index);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {UnsignedInput} b\n    */\n    add(b) {\n        _assertClass(b, UnsignedInput);\n        wasm.unsignedinputs_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Unsigned (inputs without proofs) transaction\n*/\nexport class UnsignedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedtransaction_free(ptr);\n    }\n    /**\n    * Create a new unsigned transaction\n    * @param {UnsignedInputs} inputs\n    * @param {DataInputs} data_inputs\n    * @param {ErgoBoxCandidates} output_candidates\n    */\n    constructor(inputs, data_inputs, output_candidates) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, UnsignedInputs);\n            _assertClass(data_inputs, DataInputs);\n            _assertClass(output_candidates, ErgoBoxCandidates);\n            wasm.unsignedtransaction_new(retptr, inputs.ptr, data_inputs.ptr, output_candidates.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Consumes the calling UnsignedTransaction and returns a new UnsignedTransaction containing\n    * the ContextExtension in the provided input box id or returns an error if the input box cannot be found.\n    * After the call the calling UnsignedTransaction will be null.\n    * @param {BoxId} input_id\n    * @param {ContextExtension} ext\n    * @returns {UnsignedTransaction}\n    */\n    with_input_context_ext(input_id, ext) {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(input_id, BoxId);\n            _assertClass(ext, ContextExtension);\n            wasm.unsignedtransaction_with_input_context_ext(retptr, ptr, input_id.ptr, ext.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.unsignedtransaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Inputs for transaction\n    * @returns {UnsignedInputs}\n    */\n    inputs() {\n        var ret = wasm.unsignedtransaction_inputs(this.ptr);\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.unsignedtransaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.unsignedtransaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {UnsignedTransaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.unsignedtransaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns distinct token id from output_candidates as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    distinct_token_ids() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_distinct_token_ids(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A collection of secret keys. This simplified signing by matching the secret keys to the correct inputs automatically.\n*/\nexport class Wallet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Wallet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_wallet_free(ptr);\n    }\n    /**\n    * Create wallet instance loading secret key from mnemonic\n    * Returns None if a DlogSecretKey cannot be parsed from the provided phrase\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Wallet | undefined}\n    */\n    static from_mnemonic(mnemonic_phrase, mnemonic_pass) {\n        var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.wallet_from_mnemonic(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : Wallet.__wrap(ret);\n    }\n    /**\n    * Create wallet using provided secret key\n    * @param {SecretKeys} secret\n    * @returns {Wallet}\n    */\n    static from_secrets(secret) {\n        _assertClass(secret, SecretKeys);\n        var ret = wasm.wallet_from_secrets(secret.ptr);\n        return Wallet.__wrap(ret);\n    }\n    /**\n    * Add a secret to the wallets prover\n    * @param {SecretKey} secret\n    */\n    add_secret(secret) {\n        _assertClass(secret, SecretKey);\n        wasm.wallet_add_secret(this.ptr, secret.ptr);\n    }\n    /**\n    * Sign a transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {Transaction}\n    */\n    sign_transaction(_state_context, tx, boxes_to_spend, data_boxes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            wasm.wallet_sign_transaction(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a multi signature transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {TransactionHintsBag} tx_hints\n    * @returns {Transaction}\n    */\n    sign_transaction_multi(_state_context, tx, boxes_to_spend, data_boxes, tx_hints) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            _assertClass(tx_hints, TransactionHintsBag);\n            wasm.wallet_sign_transaction_multi(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, tx_hints.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction(reduced_tx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            wasm.wallet_sign_reduced_transaction(retptr, this.ptr, reduced_tx.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a multi signature reduced transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]\n    * @param {ReducedTransaction} reduced_tx\n    * @param {TransactionHintsBag} tx_hints\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction_multi(reduced_tx, tx_hints) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            _assertClass(tx_hints, TransactionHintsBag);\n            wasm.wallet_sign_reduced_transaction_multi(retptr, this.ptr, reduced_tx.ptr, tx_hints.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate Commitments for unsigned tx\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {TransactionHintsBag}\n    */\n    generate_commitments(_state_context, tx, boxes_to_spend, data_boxes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            wasm.wallet_generate_commitments(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate Commitments for reduced Transaction\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {TransactionHintsBag}\n    */\n    generate_commitments_for_reduced_transaction(reduced_tx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            wasm.wallet_generate_commitments_for_reduced_transaction(retptr, this.ptr, reduced_tx.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign an arbitrary message using a P2PK address\n    * @param {Address} address\n    * @param {Uint8Array} message\n    * @returns {Uint8Array}\n    */\n    sign_message_using_p2pk(address, message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.wallet_sign_message_using_p2pk(retptr, this.ptr, address.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    var ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_json_parse(arg0, arg1) {\n    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_json_serialize(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = JSON.stringify(obj === undefined ? null : obj);\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_error_new(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_nipopowproof_new(arg0) {\n    var ret = NipopowProof.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_peerurls_new(arg0) {\n    var ret = PeerUrls.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_fetch_2f012da7b5bb0447(arg0) {\n    var ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_cb_drop(arg0) {\n    const obj = takeObject(arg0).original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    var ret = false;\n    return ret;\n};\n\nexport function __wbg_instanceof_Window_434ce1849eb4e0fc(arg0) {\n    var ret = getObject(arg0) instanceof Window;\n    return ret;\n};\n\nexport function __wbg_performance_bbca4ccfaef860b2(arg0) {\n    var ret = getObject(arg0).performance;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_setTimeout_1c75092906446b91() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n    return ret;\n}, arguments) };\n\nexport function __wbg_fetch_fe54824ee845f6b4(arg0, arg1) {\n    var ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_226d109446575877() { return handleError(function () {\n    var ret = new Headers();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_append_4d85f35672cbffa7() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n}, arguments) };\n\nexport function __wbg_signal_259ba662a5555524(arg0) {\n    var ret = getObject(arg0).signal;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_7456dc18cc110e9c() { return handleError(function () {\n    var ret = new AbortController();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_abort_3c64506fb0036132(arg0) {\n    getObject(arg0).abort();\n};\n\nexport function __wbg_instanceof_Response_ea36d565358a42f7(arg0) {\n    var ret = getObject(arg0) instanceof Response;\n    return ret;\n};\n\nexport function __wbg_url_6e564c9e212456f8(arg0, arg1) {\n    var ret = getObject(arg1).url;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_status_3a55bb50e744b834(arg0) {\n    var ret = getObject(arg0).status;\n    return ret;\n};\n\nexport function __wbg_headers_e4204c6775f7b3b4(arg0) {\n    var ret = getObject(arg0).headers;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_arrayBuffer_0e2a43f68a8b3e49() { return handleError(function (arg0) {\n    var ret = getObject(arg0).arrayBuffer();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_4473c9af1cac368b() { return handleError(function (arg0, arg1) {\n    var ret = new URL(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newwithstrandinit_c07f0662ece15bc6() { return handleError(function (arg0, arg1, arg2) {\n    var ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_now_5fa0ca001e042f8a(arg0) {\n    var ret = getObject(arg0).now();\n    return ret;\n};\n\nexport function __wbg_getRandomValues_3e46aa268da0fed1() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_randomFillSync_59fcc2add91fe7b3() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nexport function __wbg_process_f2b73829dbd321da(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_versions_cd82f79c98672a9f(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_ee3f6da4130bd35f(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_modulerequire_0a83c0c31d12d2c7() { return handleError(function (arg0, arg1) {\n    var ret = module.require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_crypto_9e3521ed42436d35(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_c429c3f8f7a70bb5(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    var ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_newnoargs_f579424187aa1717(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_c7a2a6b012059a5e(arg0) {\n    var ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_dd1a890d37e38d73() { return handleError(function (arg0) {\n    var ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_done_982b1c7ac0cbc69d(arg0) {\n    var ret = getObject(arg0).done;\n    return ret;\n};\n\nexport function __wbg_value_2def2d1fb38b02cd(arg0) {\n    var ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_iterator_4b9cedbeda0c0e30() {\n    var ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_get_8bbb82393651dd9c() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_89558c3e96703ca1() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_d3138911a89329b0() {\n    var ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_55259b13834a484c(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_94697a95cb7e239c() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_toString_9b85345d84562096(arg0) {\n    var ret = getObject(arg0).toString();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_4beacc9c71572250(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_410(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        var ret = new Promise(cb0);\n        return addHeapObject(ret);\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nexport function __wbg_resolve_4f8f547f26b30b27(arg0) {\n    var ret = Promise.resolve(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_a6860c82b90816ca(arg0, arg1) {\n    var ret = getObject(arg0).then(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_58a04e42527f52c6(arg0, arg1, arg2) {\n    var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_e23d74ae45fb17d1() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_b4be7f48b24ac56e() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_d61b1f48a57191ae() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_e7669da72fd7f239() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_buffer_5e74a88a1424a2e0(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_278ec7532799393a(arg0, arg1, arg2) {\n    var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_e3b800e570795b3c(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5b8081e9d002f0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_30803400a8f15c59(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_5f4ce114a24dfe1e(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_a68f835ca2af506f(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_has_3850edde6df9191b() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.has(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_c42875065132a932() { return handleError(function (arg0, arg1, arg2) {\n    var ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nexport function __wbg_stringify_f8bfc9e2d1e8b6a0() { return handleError(function (arg0) {\n    var ret = JSON.stringify(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper716(arg0, arg1, arg2) {\n    var ret = makeClosure(arg0, arg1, 111, __wbg_adapter_34);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper6314(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 859, __wbg_adapter_37);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper6396(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 925, __wbg_adapter_40);\n    return addHeapObject(ret);\n};\n\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import * as wasm from \"./ergo_lib_wasm_bg.wasm\";\nexport * from \"./ergo_lib_wasm_bg.js\";"],"sourceRoot":""}